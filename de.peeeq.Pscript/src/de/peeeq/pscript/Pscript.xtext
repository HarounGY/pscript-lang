grammar de.peeeq.pscript.Pscript hidden (WS, ML_COMMENT, SL_COMMENT) 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pscript "http://www.peeeq.de/pscript/Pscript"

Program:
	NL* packages+=PackageDeclaration (packages+=PackageDeclaration)* NL*;


	
PackageDeclaration:
  'package' name=QualifiedName '{'
  	(NL* imports+=Import)*  NL*
    (elements+=Entity NL*)*
  '}' NL*
;	

Import:
  'import' importedNamespace=QualifiedNameWithWildCard NL;

QualifiedName:
  ID ('.' ID)*;	
  
QualifiedNameWithWildCard:
  QualifiedName '.*'?;  


Entity returns NameDef:
	(ClassDef|NativeType|FuncDef|VarDef);	

/* natives: */

NativeType returns NameDef:
	{NativeType} 'native' 'type' name=ID '=' origName=ID NL
;

/* classes and their members */	

ClassDef returns NameDef:
	{ClassDef} 'class' name=ID '{' 
		(members+=ClassMember)* NL* 
	'}' NL;	

	
ClassMember returns NameDef:
	NL* (VarDef | FuncDef);
	

VarDef returns NameDef:
	{VarDef} ('var' | constant?='val') name=ID 
	( ':' type=TypeExpr )?
	( '=' e=Expr)?
	 NL
;	

TypeExpr:
	{TypeExpr} name=ID
;


/* functions */

FuncDef returns NameDef:
	{FuncDef} 'function' name=ID '(' (parameters+=ParameterDef (',' parameters+=ParameterDef)*)? ')' (':' type=TypeExpr)? '{'
		body=Statements 
	'}'
; 

ParameterDef returns NameDef:
	{ParameterDef} name=ID ':' type=TypeExpr;	

Statements:
	{Statements} (NL | statements+=Statement)*;


Statement:
	StmtIf | StmtWhile | VarDef | StmtExpr | StmtReturn;
	
StmtReturn:
	{StmtReturn} 'return' (e=Expr)? NL
;


StmtIf:
	'if' cond=Expr '{' 
		thenBlock=Statements 
	'}' ('else' '{' 
		elseBlock=Statements 
	'}')? 
;  
	
StmtWhile:
	'while' cond=Expr '{' 
		body=Statements 
	'}' 
;  	


	
StmtExpr:
	e=Expr NL
;
	
/* expressions */

/* operator precedence (weakest first):
or
and
= !=				// equals has only one (why would we need more? ;)
<= >= < >			// comparisons
+ -
* / % mod div		// mod and div work on integers, / and % 


+ -					// unary
not					// unary

.					// member
*/


Expr:
	ExprAssignment
	//ExprAtomic
;

// TODO this is not really an expression, it should only be used at top level

ExprAssignment returns Expr:
  ExprOr ({ExprAssignment.left=current} 
    op=('='|'+='|'-=') right=ExprOr)*
;

ExprOr returns Expr:
  ExprAnd ({ExprOr.left=current} 
    op='or' right=ExprAnd)*
;
 
ExprAnd returns Expr:
	ExprEquality ({ExprAnd.left=current} 
    op='and' right=ExprEquality)*
; 
 
ExprEquality returns Expr:
	ExprComparison ({ExprEquality.left=current} 
    op=('!='|'==') right=ExprComparison)*
;  
 
ExprComparison returns Expr:
	ExprAdditive ({ExprComparison.left=current} 
    op=('<='|'<'|'>='|'>') right=ExprAdditive)*
;  

ExprAdditive returns Expr:
	ExprMult ({ExprAdditive.left=current} 
    op=('+'|'-') right=ExprMult)*
;  

ExprMult returns Expr:
	ExprSign ({ExprMult.left=current} 
    op=('*'|'/'|'%'|'mod'|'div') right=ExprSign)*
;  

ExprSign returns Expr: 
      ({ExprSign} op=('+'|'-') right=ExprNot)
    | ExprNot
;  

ExprNot returns Expr: 
    ({ExprNot} op='not' right=ExprCustomOperator)
    | ExprCustomOperator
;  

ExprCustomOperator returns Expr:
	ExprMember ({ExprCustomOperator.left=current} op=OPERATOR right=Expr)*
; 

ExprMember returns Expr:
	ExprAtomic ({ExprMember.left=current} 
    op='.' right=ExprAtomic)*
;  

ExprAtomic returns Expr:
	  {ExprFunctioncall} nameVal=ID parameters=ExprList
	| {ExprFunctioncall} nameVal=ID '(' ')'
	| {ExprIdentifier} nameVal=ID
	| '(' Expr ')'
	| {ExprIntVal} intVal=INT
	| {ExprNumVal} numVal=NUMBER 
	| {ExprStrval} strVal=STRING
	| {ExprBuildinFunction} 'buildin' name=ID (parameters=ExprList | '(' ')')
	| {ExprBuildinOperator} 'buildin' '(' left=Expr op=OPERATOR right=Expr ')'	
	
//	| buildin?='buildin' name=ID parameters=ExprList
//	| buildin?='buildin' name=ID '(' ')'
//	| buildin?='buildin' '(' left=Expr op=OPERATOR right=Expr ')' // build in operators
;


ExprList:
	'(' params+=Expr (',' params+=Expr)* ')'
;	



// stolen and adjusted from java antlr grammer:


//Ref:
//	referenced=[NameDef|ID];

/* reference types 
FuncRef:
	referenced=[FuncDef|QualifiedName];

VarRef:
	referenced=[VarDef|QualifiedName];
	
TypeRef:
  referenced=[Class|QualifiedName];
	
*/
	


terminal ID  		: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal NUMBER 	: ('0..9')+ '.' ('0..9')*;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t')+;

terminal NL			: ('\n\r' | '\n' | '\r' | '\r\n');

terminal OPERATOR : ('+'|'-'|'*'|'/'|'%'|'$'|'<'|'>'|'='|'~'|'!'|'^'|'|'|'&'|':')+;

terminal ANY_OTHER: .;	
