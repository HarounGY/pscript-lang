package de.peeeq.wurstscript.parser;

import java.lang.reflect.Field;
import java.util.List;

import java_cup.runtime.Scanner;
import java_cup.runtime.Symbol;
import de.peeeq.wurstscript.utils.NotNullList;

/**
 * This parser extends the parser class generated by java-cup
 * and adds some stuff like error handling 
 *
 */
public class ExtendedParser extends parser {

	private List<ParserException> errors = new NotNullList<ParserException>();
	
	
	public void setFilename(String filename) {
		this.filename = filename;
	}
	
	@Override
	public Symbol parse() throws Exception {
		Symbol sym = super.parse();
		// Example for adding standard library:
//		CompilationUnit root = (CompilationUnit) sym.value;
//		TypeDecls typeDecls = root.typeDecls();
//		SourcePosition pos = SourcePosition(0, 0);
//		typeDecls = typeDecls.add(
//			// class IO
//			ClassDecl(
//				pos ,
//				Identifier(pos, "IO"),
//				IdentifierNone(),
//				ClassBodyDecls(
//						// static void write(int i)
//						MethodDecl(pos, Modifiers(Static(pos)), VoidT(pos), Identifier(pos, "write"), 
//								FormalParameters(FormalParameter(pos, Int(pos), Identifier(pos, "i"))), InternalMethodBody()),
//						// static int read()
//						MethodDecl(pos, Modifiers(Static(pos)), Int(pos), Identifier(pos, "read"), 
//								FormalParameters(), InternalMethodBody())				
//				)		
//		));
//		root = CompilationUnit(root.sourcePos(), typeDecls);
//		sym.value = root;
		return sym;
	}
	
	
	public ExtendedParser(Scanner scanner) {
		super(scanner);
	}

	public int getErrorCount() {
		return errors.size();
	}
	
	
	/**
	 *  returns the position of a Symbol as string 
	 */
	private String pos(Symbol s) {
		return "line " + (s.left+1) + ", column " + s.right;
	}
	
	/**
	 * uses reflection to get the name of a Symbol  
	 */
	private String translateSym(int index) {
		try {
			Class<TokenType> symbolClass = TokenType.class;
			
			for (Field f : symbolClass.getDeclaredFields()) {
				if (f.getInt(null) == index) {
					return f.getName();
				}
			}
		} catch (Throwable e) {
			e.printStackTrace();
		}
		return null;
	}
	
	private String symbolToString(Symbol s) {
		return translateSym(s.sym) +
			(s.value != null ? " " + s.value : "");
	}
	
	
	/**
	 * 
	 */
	@Override public void syntax_error(Symbol s) {
		
		String msg;
		if (s.sym == TokenType.error) {
			msg = "Lexical error in " + pos(s) + "\n" +
					"	unexpected symbol " + s.value;
		} else {
			msg = "Syntax error in " + pos(s) + "\n" + 
					"	unexpected " + symbolToString(s);
		}
		
		// get current parse state:
		int parseState = ((Symbol)stack.peek()).parse_state;
		
		msg += "	expected: ";
		// get possible actions from action table and print them
		short[] possibleActions = this.action_table()[parseState];
		
		for (int j=0; j < possibleActions.length; j+=2) {
			if (possibleActions[j] >= 0) {
				if (j > 0) {
					msg += ", ";
				}
				msg += translateSym(possibleActions[j]);
			}
		}
		ParserException err = new ParserException(msg);
		errors.add(err);
//		throw err;
	}
	
	
	@Override
	public void unrecovered_syntax_error(Symbol s) {
		printErrors();
		throw new ParserException("Could not continue to parse file ...");
	}

	private void printErrors() {
		for (ParserException err : errors) {
			System.out.println(err);
		}
	}
}
