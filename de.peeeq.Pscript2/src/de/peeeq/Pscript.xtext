grammar de.peeeq.pscript.Pscript hidden (WS, ML_COMMENT, SL_COMMENT) 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pscript "http://www.peeeq.de/pscript/Pscript"

Program:
	NL* packages+=PackageDeclaration (packages+=PackageDeclaration)* NL*;






	
PackageDeclaration:
  {PackageDeclaration} 'package' name=ID '{'
  	(NL* imports+=Import)*  NL*
    (elements+=Entity NL*)*
  '}' NL*
;	

Import:
  'import' importedNamespace=ImportString NL;

ImportString:
	ID '.' ('*'|ID)
;



Entity:
	(TypeDef|FuncDef|VarDef|InitBlock);

InitBlock:
	name='init' '{' body=Statements '}'
;
	





TypeDef: 
	(NativeType|ClassDef)
;

NativeType returns TypeDef:
	{NativeType} 'native' 'type' name=ID '=' origName=ID ('extends' superName=TypeExpr)? NL
;

/* classes and their members */	

ClassDef returns TypeDef:
	{ClassDef} 'class' name=ID '{' 
		(members+=ClassMember)* NL* 
	'}' NL;	

	
ClassMember:
	NL* (VarDef | FuncDef);
	

VarDef:
	{VarDef} ('var' | constant?='val') name=ID 
	( ':' type=TypeExpr )?
	( '=' e=Expr)?
	 NL
;	

TypeExpr:
	{TypeExpr} name=[TypeDef]
;


/* functions */

FuncDef:
	{FuncDef} 'function' name=ID '(' (parameters+=ParameterDef (',' parameters+=ParameterDef)*)? ')' (':' type=TypeExpr)? '{'
		body=Statements 
	'}'
; 

ParameterDef returns VarDef:
	{ParameterDef} name=ID ':' type=TypeExpr;	

Statements:
	{Statements} (NL | statements+=Statement)*;


Statement:
	StmtIf | StmtWhile | VarDef | StmtExpr | StmtReturn;
	
StmtReturn:
	{StmtReturn} 'return' (e=Expr)? NL
;


StmtIf:
	'if' cond=Expr '{' 
		thenBlock=Statements 
	'}' ('else' elseBlock=ElseBlock)? 
;

ElseBlock:
	('{' Statements	'}')
	| ElseIfBlock
;

ElseIfBlock returns Statements:
	statements+=StmtIf
;

  
	
StmtWhile:
	'while' cond=Expr '{' 
		body=Statements 
	'}' 
;  	


	
StmtExpr:
	e=Expr NL
;
	
/* expressions */

/* operator precedence (weakest first):
or
and
== !=				// 
<= >= < >			// comparisons
+ -
* / % mod div		// mod and div work on integers, / and % for reals


+ -					// unary
not					// unary

.					// member
*/


Expr:
	ExprAssignment
	//ExprAtomic
;

// TODO this is not really an expression, it should only be used at top level

ExprAssignment returns Expr:
  ExprOr ({ExprAssignment.left=current} 
    op=OpAssignment right=ExprOr)*
;

OpAssignment:
	{OpAssign} '='| {OpPlusAssign}'+='| {OpMinusAssign}'-='
;


ExprOr returns Expr:
  ExprAnd ({ExprOr.left=current} 
    op='or' right=ExprAnd)*
;
 
ExprAnd returns Expr:
	ExprEquality ({ExprAnd.left=current} 
    op='and' right=ExprEquality)*
; 
 
ExprEquality returns Expr:
	ExprComparison ({ExprEquality.left=current} 
    op=OpEquality right=ExprComparison)*
;

OpEquality:
	 {OpEquals} '=='
	| {OpUnequals} '!='
;
  
 
ExprComparison returns Expr:
	ExprAdditive ({ExprComparison.left=current} 
    op=OpComparison right=ExprAdditive)*
;

OpComparison:
		{OpLessEq} '<='
	|	{OpLess} '<'
	| 	{OpGreaterEq} '>='
	| 	{OpGreater} '>'
;
  

ExprAdditive returns Expr:
	ExprMult ({ExprAdditive.left=current} 
    op=OpAdditive right=ExprMult)*
;

OpAdditive:
		{OpPlus} '+'
	|	{OpMinus} '-'
;
  

ExprMult returns Expr:
	ExprSign ({ExprMult.left=current} 
    op=OpMultiplicative right=ExprSign)*
;

OpMultiplicative:
		{OpMult} '*'
	|	{OpDivReal} '/'
	|	{OpModReal} '%'
	|	{OpModInt} 'mod'
	|	{OpModReal} 'div'
;
  

ExprSign returns Expr: 
      ({ExprSign} op=OpAdditive right=ExprNot)
    | ExprNot
;  

ExprNot returns Expr: 
    ({ExprNot} 'not' right=ExprMember)
    | ExprMember
;  

//ExprCustomOperator returns Expr:
//	ExprMember ({ExprCustomOperator.left=current} op=OPERATOR right=Expr)*
//; 

ExprMember returns Expr:
	ExprSingle ({ExprMember.left=current} 
    '.' right=ExprAtomic)*
;





ExprSingle returns Expr:
	  ExprAtomic
	| '(' Expr ')'
	| {ExprIntVal} intVal=INT
	| {ExprNumVal} numVal=Number 
	| {ExprStrval} strVal=STRING
	| {ExprBoolVal} boolVal=('true'|'false')
	| {ExprBuildinFunction} 'buildin' name=ID (parameters=ExprList | '(' ')')
//	| {ExprBuildinOperator} 'buildin' '(' left=Expr op=OPERATOR right=Expr ')'	
	
//	| buildin?='buildin' name=ID parameters=ExprList
//	| buildin?='buildin' name=ID '(' ')'
//	| buildin?='buildin' '(' left=Expr op=OPERATOR right=Expr ')' // build in operators
;

Number:
	INT '.' INT
;


ExprAtomic returns Expr:
	  {ExprFunctioncall} nameVal=[FuncDef] parameters=ExprList
	| {ExprFunctioncall} nameVal=[FuncDef] '(' ')'
	| {ExprIdentifier} nameVal=[VarDef]
;


ExprList:
	'(' params+=Expr (',' params+=Expr)* ')'
;	


// Pseudo rules to add common super types:


	
// Terminals:
terminal ID  		: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		;
		
		
// multiline comments changed to consume whitespace to make the javadoc work		
terminal ML_COMMENT	: '/*' -> '*/' (' '|'\t'|'\n'|'\r')*;  
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t')+;

terminal NL			: ('\n\r' | '\n' | '\r' | '\r\n');


//terminal OPERATOR : ('+'|'-'|'*'|'/'|'%'|'$'|'<'|'>'|'='|'~'|'!'|'^'|'|'|'&'|':')+;

terminal ANY_OTHER: .;	
