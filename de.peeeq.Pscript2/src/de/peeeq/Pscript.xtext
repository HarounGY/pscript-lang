grammar de.peeeq.pscript.Pscript hidden (WS, ML_COMMENT, SL_COMMENT) 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pscript "http://www.peeeq.de/pscript/Pscript"

Program:
	NL* packages+=PackageDeclaration (packages+=PackageDeclaration)* NL*;






	
PackageDeclaration:
  {PackageDeclaration} 'package' name=ID '{' NL
  	(NL* imports+=Import)*  NL*
    (elements+=Entity NL*)*
  '}' NL
;	

Import:
  'import' importedNamespace=ImportString NL;

ImportString:
	ID '.' ('*'|ID)
;



Entity:
	(TypeDef|FuncDef|VarDef|InitBlock|NativeFunc);

InitBlock:
	name='init' '{' NL
	 	body=Statements 
	'}' NL
;
	





TypeDef: 
	(NativeType|ClassDef)
;

NativeFunc returns FuncDef:
	{NativeFunc} 'native' name=ID 
				'(' (parameters+=ParameterDef (',' parameters+=ParameterDef)*)? ')'
				('returns' type=TypeExpr)?
				 NL
;


NativeType returns TypeDef:
	{NativeType} 'nativetype' name=ID ('extends' superName=TypeExpr)? NL
;

/* classes and their members */	

ClassDef returns TypeDef:
	{ClassDef} (unmanaged?='unmanaged')? 'class' name=ID '{'   NL
		(NL | members+=ClassSlots)*  
	'}' NL;	


ClassSlots:
	ConstructorDef | OnDestroyDef | ClassMember
;

	
ClassMember:
	(VarDef | FuncDef);



	

VarDef:
	{VarDef} (
		  constant?='val' (type=TypeExpr)? name=ID '=' e=Expr
		| type=TypeExpr name = ID ('=' e=Expr)?
	) 
	 NL
;

	

TypeExpr:
		name=[TypeDef] (array?='array' ('['sizes+=INT']')*)?
;
/* buildin types are handled by nativetype defs in natives.pscript	
   	| {TypeExprBuildin} 
			name=(
				  'integer' 
				| 'real' 
				| 'string'
				| 'boolean'
				| 'handle'
				| 'code'
			)
 */



/* functions */

ConstructorDef:
	'construct' 
				  '(' (parameters+=ParameterDef (',' parameters+=ParameterDef)*)? ')'
			'{' NL
		body=Statements 
	'}' NL
	 
; 

OnDestroyDef:
	'onDestroy' '{' NL
		body=Statements
	'}' NL
;

FuncDef:
	'function' name=ID 
				  '(' (parameters+=ParameterDef (',' parameters+=ParameterDef)*)? ')'
			('returns' type=TypeExpr)?
			'{' NL
		body=Statements 
	'}' NL
	 
; 

ParameterDef returns VarDef:
	{ParameterDef}  type=TypeExpr name=ID;	

Statements:
	{Statements} (NL | statements+=Statement)*;


Statement:
	StmtIf | StmtWhile | LocalVarDef | StmtSetOrCallOrVarDef | StmtReturn | StmtDestroy | StmtChangeRefCount
	//| StmtLoop | StmtExitwhen
;

StmtChangeRefCount:
	(increase?='incref'|decrease?='decref') obj=Expr NL
;




StmtDestroy:
	'destroy' obj=Expr NL
;





/* maybe later:

StmtExitwhen:
	'exitwhen' e=Expr NL
;


StmtLoop:
	'loop' NL
		body=Statements
	'endloop' NL
;
*/



	
StmtReturn:
	{StmtReturn} 'return' (e=Expr)? NL
;


StmtIf:
	'if' cond=Expr '{' NL 
		thenBlock=Statements 
	'}'		
	(
		'else' '{' NL 
			elseBlock=Statements
		'}' 
	)?
	NL
;


  
	
StmtWhile:
	'while' cond=Expr '{' NL 
		body=Statements 
	'}' NL
;  	



LocalVarDef returns VarDef: // TODO requires backtracking
	{VarDef} constant?='val' (type=TypeExpr)? name=ID ( '=' e=Expr)? NL
	| {VarDef} type=TypeExpr name=ID  ( '=' e=Expr)? NL
;


StmtSetOrCallOrVarDef:
	 {StmtCall} e=Expr ({StmtSet.left=current} opAssignment=OpAssignment right=Expr)?  NL
;


OpAssignment:
	{OpAssign} '='| {OpPlusAssign}'+='| {OpMinusAssign}'-='
;
	
/* expressions */

/* operator precedence (weakest first):
or
and
== !=				// 
<= >= < >			// comparisons
+ -
* / % mod div		// mod and div work on integers, / and % for reals


+ -					// unary
not					// unary

.					// member
*/


Expr:
	ExprOr
;

// TODO this is not really an expression, it should only be used at top level






ExprOr returns Expr:
  ExprAnd ({ExprOr.left=current} 
    op='or' right=ExprAnd)*
;
 
ExprAnd returns Expr:
	ExprEquality ({ExprAnd.left=current} 
    op='and' right=ExprEquality)*
; 
 
ExprEquality returns Expr:
	ExprComparison ({ExprEquality.left=current} 
    op=OpEquality right=ExprComparison)*
;

OpEquality:
	 {OpEquals} '=='
	| {OpUnequals} '!='
;
  
 
ExprComparison returns Expr:
	ExprAdditive ({ExprComparison.left=current} 
    op=OpComparison right=ExprAdditive)*
;

OpComparison:
		{OpLessEq} '<='
	|	{OpLess} '<'
	| 	{OpGreaterEq} '>='
	| 	{OpGreater} '>'
;
  

ExprAdditive returns Expr:
	ExprMult ({ExprAdditive.left=current} 
    op=OpAdditive right=ExprMult)*
;

OpAdditive:
		{OpPlus} '+'
	|	{OpMinus} '-'
;
  

ExprMult returns Expr:
	ExprSign ({ExprMult.left=current} 
    op=OpMultiplicative right=ExprSign)*
;

OpMultiplicative:
		{OpMult} '*'
	|	{OpDivReal} '/'
	|	{OpModReal} '%'
	|	{OpModInt} 'mod'
	|	{OpDivInt} 'div'
;
  

ExprSign returns Expr: 
      ({ExprSign} op=OpAdditive right=ExprNot)
    | ExprNot
;  

ExprNot returns Expr: 
    ({ExprNot} 'not' right=ExprMember)
    | ExprMember
;  

//ExprCustomOperator returns Expr:
//	ExprMember ({ExprCustomOperator.left=current} op=OPERATOR right=Expr)*
//; 

ExprMember returns Expr:
	ExprSingle ({ExprMember.left=current} 
    '.' message=ExprMemberRight)*
;

ExprMemberRight:
	nameVal=[ClassMember] ('(' (params+=Expr (',' params+=Expr)*)? ')' )?
	
//	  {ExprMemberVar}   nameVal=[VarDef]
//	| {ExprMemberMethod} nameVal=[FuncDef] parameters=ExprList
//	| {ExprMemberMethod} nameVal=[FuncDef] '(' ')'
;






ExprSingle returns Expr:
	  ExprAtomic
	| '(' Expr ')'
	| {ExprIntVal} intVal=INT
	| {ExprNumVal} numVal=Number 
	| {ExprStrval} strVal=STRING
	| {ExprBoolVal} boolVal=('true'|'false')
	| {ExprFuncRef} 'function' nameVal=[FuncDef]
//	| {ExprBuildinFunction} 'buildin' name=ID (parameters=ExprList | '(' ')')
//	| {ExprBuildinOperator} 'buildin' '(' left=Expr op=OPERATOR right=Expr ')'	
	
//	| buildin?='buildin' name=ID parameters=ExprList
//	| buildin?='buildin' name=ID '(' ')'
//	| buildin?='buildin' '(' left=Expr op=OPERATOR right=Expr ')' // build in operators
;

Number:
	INT '.' INT
;


ExprAtomic returns Expr:
	ExprFunctionCall 
	| {ExprIdentifier} nameVal=[VarDef] ('[' arrayIndizes+=Expr ']' )*
	| {ExprNewObject} 'new' classDef=[ClassDef] '(' (params+=Expr (',' params+=Expr)*)? ')'
	| {ExprThis} 'this'
;


ExprFunctionCall returns Expr:
	{ExprFunctioncall} nameVal=[FuncDef] '(' (params+=Expr (',' params+=Expr)*)? ')'
;




// Pseudo rules to add common super types:


	
// Terminals:
terminal ID  		: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+; // TODO special ints (hex, oct, ascii)
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' 
		;
		
		
// multiline comments changed to consume whitespace to make the javadoc work		
terminal ML_COMMENT	: '/*' -> '*/' (' '|'\t'|'\n'|'\r')*;  
terminal SL_COMMENT 	: ('//' !('\n'|'\r')*) 
;

terminal WS			: ('\\\n\r' | '\\\n' | '\\\r' | '\\\r\n'|' '|'\t')+;

terminal NL			: ('\n\r' | '\n' | '\r' | '\r\n');


//terminal OPERATOR : ('+'|'-'|'*'|'/'|'%'|'$'|'<'|'>'|'='|'~'|'!'|'^'|'|'|'&'|':')+;

terminal ANY_OTHER: .;	
